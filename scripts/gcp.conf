#!/bin/bash
# gcp.conf.sh - Configuración centralizada de GCP


# RUTAS PRINCIPALES
# ============================================================================

# Repositorio de origen (de donde se extraerán los commits)
export REPO_ORIGEN="$HOME/repos/linux-qclaptops"

# Repositorio de destino (donde se aplicarán los parches)
export REPO_DESTINO="$HOME/snapdragon/repos/gitlab/linaro-qcom-laptops"


# Ramas
export BRANCH_ORIGEN="uwu-next"
export BRANCH_DESTINO="uwu-patchs"


# DIRECTORIOS 
# ============================================================================

# GCP home directory (where GCP lives)
export GCP_HOME="${GCP_HOME:-.}"  # Default: current directory, or use env var ~/.local ...

# Sistema de estado
export PATCHES_STATE="$GCP_HOME/state"
export PROCESSED_COMMITS_LOG="$PATCHES_STATE/processed_commits.log"
export SERIES_COUNTER_FILE="$PATCHES_STATE/series_counter.txt"

# Directorios específicos
export PATCHES_APPLIED="$GCP_HOME/applied"
export PATCHES_CANDIDATES="$GCP_HOME/candidates"
export PATCHES_PENDING="$GCP_HOME/pending"
export PATCHES_LOGS="$GCP_HOME/logs"
export PATCHES_PANDORA="$GCP_HOME/pandora"
export PATCHES_TMP="$GCP_HOME/tmp"
export PATCHES_SCRIPTS="$GCP_HOME/scripts"


# NOMBRES DE ARCHIVOS POR DEFECTO
# ============================================================================

# Nombres por defecto para archivos de entrada/salida
export DEFAULT_LOG_FILE="apply_errors.log"
export DEFAULT_FILE_LIST="archivos_conflictivos.txt"
export DEFAULT_COMMITS_LIST="commits_encontrados.tsv"
export DEFAULT_PANDORA_PATCH="pandora.patch"


# CONFIGURACIÓN DE BÚSQUEDA DE COMMITS
# ============================================================================

# Fecha por defecto para buscar commits (momento 0: v6.18)
export DEFAULT_SINCE_DATE="2024-08-01"

# Límite por defecto de commits a buscar
export DEFAULT_COMMIT_LIMIT=100


# FUNCIONES
# ============================================================================

# Mostrar configuración, util en debug
show_config() {
    echo "CONFIGURACIÓN GCP"
    echo ""
    echo "DIRECTORIOS:"
    echo "  REPO_ORIGEN:     $REPO_ORIGEN"
    echo "  REPO_DESTINO:    $REPO_DESTINO"
    echo "  GCP_HOME:        $GCP_HOME"
    echo "  PATCHES_STATE:   $PATCHES_STATE"
    echo "  APPLIED:         $PATCHES_APPLIED"
    echo "  CANDIDATES:      $PATCHES_CANDIDATES"
    echo "  PENDING:         $PATCHES_PENDING"
    echo "  LOGS:            $PATCHES_LOGS"
    echo "  PANDORA:         $PATCHES_PANDORA"
    echo "  SCRIPTS:         $PATCHES_SCRIPTS"
    echo "  TMP:             $PATCHES_TMP"
    echo ""
    echo "CONFIGURACIÓN:"
    echo "  BRANCH_ORIGEN:   $BRANCH_ORIGEN"
    echo "  BRANCH_DESTINO:  $BRANCH_DESTINO"
    echo "  SINCE_DATE:      $DEFAULT_SINCE_DATE"
    echo "  COMMIT_LIMIT:    $DEFAULT_COMMIT_LIMIT"
    echo ""
}

# Crear todos los directorios si no existen
create_directories() {
    echo "Creando estructura de directorios GCP..."
    mkdir -p "$PATCHES_APPLIED"
    mkdir -p "$PATCHES_CANDIDATES"
    mkdir -p "$PATCHES_PENDING"
    mkdir -p "$PATCHES_LOGS"
    mkdir -p "$PATCHES_PANDORA"
    mkdir -p "$PATCHES_SCRIPTS"
    mkdir -p "$PATCHES_TMP"
    mkdir -p "$PATCHES_STATE"
    echo "Structure created in: $GCP_HOME"
}

# Extraer hash de un archivo patch
extract_hash_from_patch() {
    local patch_file="$1"
    # Buscar línea "From <hash>" en el patch (formato estándar de git format-patch)
    grep -m1 "^From " "$patch_file" 2>/dev/null | awk '{print $2}' | cut -c1-12
}

# Función para pausa simple
pause() {
    echo ""
    echo "  Continuar..."
    read -r
}


# FUNCIONES DE NUMERACIÓN PARA PATCHS
# ============================================================================

# Obtener siguiente número para una serie (busca en todos los directorios)
get_next_patch_number() {
    local serie_num="$1"
    local max_num=0
    
    # Buscar en TODOS los directorios relevantes
    for dir in "$PATCHES_CANDIDATES" "$PATCHES_APPLIED" "$PATCHES_PENDING"; do
        [ -d "$dir" ] || continue
        
        # Buscar archivos que coincidan con S{n}_nnn
        for patch_file in "$dir"/S${serie_num}_*.patch; do
            [ -f "$patch_file" ] || continue
            
            # Extraer el número (ej: S1_045-foo.patch → 45)
            num=$(basename "$patch_file" | sed -n "s/^S${serie_num}_0*\([0-9]\+\).*/\1/p")
            if [[ "$num" =~ ^[0-9]+$ ]] && [ "$num" -gt "$max_num" ]; then
                max_num="$num"
            fi
        done
    done
    
    # Devolver siguiente número con 3 dígitos
    printf "%03d" $((max_num + 1))
}

# Generar nombre de archivo descriptivo
format_patch_name() {
    local serie_num="$1"
    local patch_num="$2"  # Ya formateado como 001, 002, etc.
    local description="$3"
    # Limpiar descripción para nombre de archivo seguro
    local clean_desc=$(echo "$description" | sed 's/[^a-zA-Z0-9._-]/-/g' | cut -c1-40)
    printf "S%d_%s-%s.patch" "$serie_num" "$patch_num" "$clean_desc"
}

# Verificar si un hash ya fue procesado
is_hash_processed() {
    local hash="$1"
    [ -f "$PROCESSED_COMMITS_LOG" ] && grep -q "^$hash$" "$PROCESSED_COMMITS_LOG"
}

# Registrar hash procesado
register_hash() {
    local hash="$1"
    if [ -n "$hash" ] && ! is_hash_processed "$hash"; then
        echo "$hash" >> "$PROCESSED_COMMITS_LOG"
        return 0
    fi
    return 1
}

# Función para mostrar mensaje de inicio de script
script_header() {
    local script_name="$1"
    echo "GCP : $script_name"
    echo ""
}
